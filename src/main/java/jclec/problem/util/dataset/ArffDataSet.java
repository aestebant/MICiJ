package jclec.problem.util.dataset;

import jclec.problem.classification.classic.ClassicClassificationMetadata;
import jclec.problem.classification.classic.ClassicInstance;
import jclec.problem.classification.multiinstance.MIBag;
import jclec.problem.classification.multiinstance.MIClassificationMetadata;
import jclec.problem.classification.multilabel.MLClassificationMetadata;
import jclec.problem.classification.multilabel.MLInstance;
import jclec.problem.util.dataset.attribute.AttributeType;
import jclec.problem.util.dataset.attribute.CategoricalAttribute;
import jclec.problem.util.dataset.attribute.IAttribute;
import jclec.problem.util.dataset.attribute.NumericalAttribute;
import jclec.util.range.Closure;
import jclec.util.range.Interval;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/**
 * ArffDataset implementation (Weka dataset)
 *
 * @author Alberto Cano
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna
 * @author Juan Luis Olmo
 */

public class ArffDataSet extends AbstractDataset {
    /////////////////////////////////////////////////////////////////
    // --------------------------------------- Serialization constant
    /////////////////////////////////////////////////////////////////

    /**
     * Generated by Eclipse
     */

    private static final long serialVersionUID = 1L;

    /////////////////////////////////////////////////////////////////
    // ------------------------------------------- Internal Variables
    /////////////////////////////////////////////////////////////////

    /**
     * The keyword used to denote the relation name
     */

    static String ARFF_RELATION = "@relation";

    /**
     * The keyword used to denote the attribute description
     */

    static String ARFF_ATTRIBUTE = "@attribute";

    /**
     * The keyword used to denote the start of the arff data section
     */

    static String ARFF_DATA = "@data";

    /**
     * Symbol which represents missed values
     */

    protected String missedValue;

    /**
     * Symbol which represents commentted values
     */

    protected String commentedValue;

    /**
     * Symbol which represents the separation between values
     */

    protected String separationValue;

    /////////////////////////////////////////////////////////////////
    // -------------------------------------------------- Constructor
    /////////////////////////////////////////////////////////////////

    public ArffDataSet() {
        super();

        missedValue = "?";
        separationValue = ",";
        commentedValue = "%";
    }

    /////////////////////////////////////////////////////////////////
    // ----------------------------------------------- Public methods
    /////////////////////////////////////////////////////////////////

    /**
     * Load examples from the data set
     * <p>
     * Open dataset, obtain metadata, read examples, close dataset
     */

    public void loadExamples() {
        File datasetFile = new File(fileName);
        BufferedReader fileReader;

        examples = new ArrayList<>();

        try {
            // Open dataset
            fileReader = new BufferedReader(new FileReader(datasetFile));

            // Read the dataset
            readLoop:
            do {
                StringTokenizer tokenizer;
                String line = "", str = "";

                // Read next line
                while (line.startsWith(commentedValue) || line.equalsIgnoreCase("")) {
                    line = fileReader.readLine();

                    if (line == null) {
                        // Check if all the metadata information have been loaded
                        if (metadata instanceof MLClassificationMetadata)
                            if (metadata.numberOfClasses() == -1)
                                System.err.println("The dataset specification xml have not been defined");

                        break readLoop;
                    }
                }

                // Fix attribute information
                if (line.startsWith(ARFF_ATTRIBUTE)) {
                    int index = line.indexOf('[');
                    if (index != -1)
                        line = line.substring(0, index) + " [" + line.substring(index + 1);

                    index = line.indexOf('{');
                    if (index != -1)
                        line = line.substring(0, index) + " {" + line.substring(index + 1);
                }

                // Tokenizer the line
                tokenizer = new StringTokenizer(line);
                str = tokenizer.nextToken();

                // Proccess the dataset name
                if (str.equalsIgnoreCase(ARFF_RELATION)) {
                    String name = tokenizer.nextToken();
                    setName(name);
                    continue;
                }

                // Process data
                if (str.equalsIgnoreCase(ARFF_DATA)) {
                    continue;
                }

                // Process @end bag
                if (str.equalsIgnoreCase("@end")) {
                    continue;
                }

                // Proccess the attribue
                if (str.equalsIgnoreCase(ARFF_ATTRIBUTE)) {
                    String name = tokenizer.nextToken();
                    String type = tokenizer.nextToken();

                    if (name.equalsIgnoreCase("id_student"))
                        continue;

                    if (type.equalsIgnoreCase("REAL") || type.equalsIgnoreCase("NUMERIC")) {
                        addAttributeToSpecification(type, line, name);
                    } else if (type.equalsIgnoreCase("RELATIONAL")) {
                        // Ignore and read next the relational attributes
                    } else
                        addAttributeToSpecification("STRING", line, name);

                    continue;
                }

                tokenizer = new StringTokenizer(line, separationValue);

                if (metadata instanceof MIClassificationMetadata) {
                    // Bag of instances
                    MIBag bag = null;

                    // Parse the bag identification
                    String bagStr = line.substring(0, line.indexOf(separationValue));
                    IAttribute attribute = metadata.getAttribute(0);
                    double bagID = attribute.parse(bagStr);

                    // Check if the bag has been already created
                    for (IExample iterator : examples)
                        if (((MIBag) iterator).getBagID() == bagID)
                            bag = (MIBag) iterator;

                    // Create the bag if not found
                    if (bag == null) {
                        bag = new MIBag();

                        // Set bag identification
                        bag.setBagID(bagID);

                        // Add the bag to the dataset
                        examples.add(bag);
                    }

                    if (((MIClassificationMetadata) metadata).getClassIndex() == -1)
                        ((MIClassificationMetadata) metadata).setClassIndex(metadata.numberOfAttributes());

                    // Parse class value
                    String Class = line.substring(line.lastIndexOf(separationValue) + 1);
                    attribute = ((MIClassificationMetadata) metadata).getClassAttribute();
                    double classValue = attribute.parse(Class);

                    // Set the bag class value
                    bag.setClassValue(classValue);

                    // Obtain instances values
                    String valuesStr = line.substring(line.indexOf(separationValue) + 2, line.lastIndexOf(separationValue) - 1);

                    // Split instances
                    //StringTokenizer token = new StringTokenizer(valuesStr, Pattern.quote("\n"));
                    StringTokenizer token = new StringTokenizer(valuesStr, "\\n");
                    while (token.hasMoreTokens()) {
                        String[] valuesInstanceStr = token.nextToken().trim().split(separationValue);
                        //System.out.println(Arrays.toString(valuesInstanceStr));
                        double[] values = new double[metadata.numberOfAttributes()];

                        // Set the bag ID
                        values[0] = bagID;

                        // Obtain instance values
                        for (int i = 1; i < metadata.numberOfAttributes(); i++) {
                            attribute = metadata.getAttribute(i);
                            values[i] = attribute.parse(valuesInstanceStr[i - 1].trim());
                        }

                        // Fix (if required) last attribute value
                        attribute = metadata.getAttribute(metadata.numberOfAttributes() - 1);

                        if (valuesInstanceStr[metadata.numberOfAttributes() - 2].contains(","))
                            values[values.length - 1] = attribute.parse(valuesInstanceStr[metadata.numberOfAttributes() - 2].substring(0, valuesInstanceStr[metadata.numberOfAttributes() - 2].length() - 1).trim());
                        else
                            values[values.length - 1] = attribute.parse(valuesInstanceStr[metadata.numberOfAttributes() - 2].trim());

                        // Create instance
                        Instance instance = new Instance(metadata.numberOfAttributes());
                        instance.setValues(values);

                        // Add the instance to the bag
                        bag.addInstance(instance);
                    }
                } else if (metadata instanceof MLClassificationMetadata) {
                    // Instance values
                    double[] values = new double[metadata.numberOfAttributes()];

                    // Parse each attribute value
                    for (int i = 0; i < metadata.numberOfAttributes(); i++) {
                        IAttribute attribute = metadata.getAttribute(i);
                        values[i] = attribute.parse(tokenizer.nextToken().trim());
                    }

                    // Class values
                    double[] classValues = new double[metadata.numberOfClasses()];

                    // Parse class values
                    for (int i = 0; i < metadata.numberOfClasses(); i++) {
                        String value = tokenizer.nextToken().trim();
                        classValues[i] = Double.parseDouble(value);
                    }

                    // Create instance
                    MLInstance instance = new MLInstance(metadata.numberOfAttributes());
                    instance.setValues(values);
                    instance.setClassValues(classValues);

                    //Add the instance to the dataset
                    examples.add(instance);
                } else {
                    // Instance values
                    double[] values = new double[metadata.numberOfAttributes()];

                    // Parse each attribute value
                    for (int i = 0; i < metadata.numberOfAttributes(); i++) {
                        IAttribute attribute = metadata.getAttribute(i);
                        values[i] = attribute.parse(tokenizer.nextToken().trim());
                    }

                    if (((ClassicClassificationMetadata) metadata).getClassIndex() == -1)
                        ((ClassicClassificationMetadata) metadata).setClassIndex(metadata.numberOfAttributes());

                    // Parse class value
                    IAttribute attribute = ((ClassicClassificationMetadata) metadata).getClassAttribute();
                    double classValue = attribute.parse(tokenizer.nextToken().trim());

                    // Create instance
                    ClassicInstance instance = new ClassicInstance(metadata.numberOfAttributes());
                    instance.setValues(values);
                    instance.setClassValue(classValue);

                    //Add the instance to the dataset
                    examples.add(instance);
                }
            }
            while (true);

            fileReader.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        computeAttributeDomains();
    }

    /**
     * Set the dataset examples
     *
     * @param examples the examples
     */

    public void setExamples(ArrayList<IExample> examples) {
        this.examples = examples;
    }

    /**
     * Get the dataset examples
     *
     * @return examples
     */

    public ArrayList<IExample> getExamples() {
        return examples;
    }

    /**
     * Add the new examples to the dataset
     *
     * @param newexamples examples to add
     */

    public void addExamples(ArrayList<IExample> newexamples) {
        this.examples.addAll(newexamples);
    }

    /////////////////////////////////////////////////////////////////
    // ---------------------------------------------- Private Methods
    /////////////////////////////////////////////////////////////////

    /**
     * Add new attribute to the dataset specification
     *
     * @param type     Attribute type
     * @param interval Intervals value
     * @param name     Attribute name
     */
    private void addAttributeToSpecification(String type, String interval, String name) {
        // If the attribute is numerical
        if (type.equalsIgnoreCase("REAL") || type.equalsIgnoreCase("NUMERIC")) {
            NumericalAttribute attribute = new NumericalAttribute();
            attribute.setName(name);

            Interval intervals = new Interval();

            intervals.setClosure(Closure.ClosedClosed);

            attribute.setInterval(intervals);

            //Add new attribute to the specification
            metadata.addAttribute(attribute);
        } else {
            //Obtain the categorical values
            int minIndex = interval.indexOf("{");
            int maxIndex = interval.indexOf("}");

            interval = interval.substring(minIndex + 1, maxIndex);

            if (minIndex < maxIndex) {
                CategoricalAttribute attribute = new CategoricalAttribute();
                attribute.setName(name);

                StringTokenizer categories = new StringTokenizer(interval, ",");
                List<String> categoriesList = new ArrayList<String>();

                while (categories.hasMoreTokens())
                    categoriesList.add(categories.nextToken().trim());

                attribute.setCategories(categoriesList);

                //Add new attribute to the specification
                metadata.addAttribute(attribute);
            }
        }
    }

    /**
     * Compute attribute domains
     */

    private void computeAttributeDomains() {
        double[] minValues = new double[metadata.numberOfAttributes()];
        double[] maxValues = new double[metadata.numberOfAttributes()];

        for (int i = 0; i < metadata.numberOfAttributes(); i++) {
            minValues[i] = Double.MAX_VALUE;
            maxValues[i] = -Double.MAX_VALUE;
        }

        if (metadata instanceof MIClassificationMetadata) {
            for (IExample bag : examples) {
                for (IExample instance : ((MIBag) bag).getInstances()) {
                    for (int i = 0; i < metadata.numberOfAttributes(); i++) {
                        double value = instance.getValue(i);

                        if (value < minValues[i])
                            minValues[i] = value;
                        if (value > maxValues[i])
                            maxValues[i] = value;
                    }
                }
            }

            for (int i = 0; i < metadata.numberOfAttributes(); i++)
                if (metadata.getAttribute(i).getType() == AttributeType.Numerical) {
                    Interval interval = new Interval(minValues[i], maxValues[i], Closure.ClosedClosed);
                    ((NumericalAttribute) metadata.getAttribute(i)).setInterval(interval);
                }
        } else {
            for (IExample instance : examples) {
                for (int i = 0; i < metadata.numberOfAttributes(); i++) {
                    double value = instance.getValue(i);

                    if (value < minValues[i])
                        minValues[i] = value;
                    if (value > maxValues[i])
                        maxValues[i] = value;
                }
            }

            for (int i = 0; i < metadata.numberOfAttributes(); i++)
                if (metadata.getAttribute(i).getType() == AttributeType.Numerical) {
                    Interval interval = new Interval(minValues[i], maxValues[i], Closure.ClosedClosed);
                    ((NumericalAttribute) metadata.getAttribute(i)).setInterval(interval);
                }
        }
    }

    /**
     * Copy method
     *
     * @return A copy of this dataset
     */

    @Override
    public IDataset copy() {

        ArffDataSet dataset = new ArffDataSet();

        dataset.setName(datasetName);
        dataset.setMetadata(metadata.copy());

        ArrayList<IExample> examples = new ArrayList<>();

        for (IExample example : this.examples)
            examples.add(example.copy());

        dataset.setExamples(examples);

        return dataset;
    }
}