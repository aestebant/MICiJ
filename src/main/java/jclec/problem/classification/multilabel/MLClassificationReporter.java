package jclec.problem.classification.multilabel;

import jclec.problem.classification.ClassificationReporter;
import jclec.problem.classification.IClassifier;
import jclec.problem.util.dataset.IDataset;
import jclec.problem.util.dataset.IExample;
import jclec.problem.util.dataset.attribute.IAttribute;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 * Listener for multi-label classification algorithms
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Juan Luis Olmo
 */

public abstract class MLClassificationReporter extends ClassificationReporter
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8548482239030974796L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Constructor
	 */
	
	public MLClassificationReporter() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * This method classifies a dataset and write the results in the FileWriter
	 * 
	 * @param dataset The dataset
	 * @param classifier The classifier
	 * @param file The file to write
	 */
    @Override
    protected void classify(IDataset dataset, IClassifier classifier, FileWriter file)
    {
    	MLClassificationMetadata metadata = (MLClassificationMetadata) dataset.getMetadata();
		int numAttributes = metadata.numberOfAttributes();
		
		double[][] predicted = ((IMLClassifier) classifier).classify(dataset);
		ArrayList<IExample> instances = dataset.getExamples();
		
    	try {
    		file.write("DATASET: " + dataset.getName());
    		
    		for(int i = 0; i < instances.size(); i++)
        	{
    			double[] Classes = ((MLInstance) instances.get(i)).getClassValues();
				
				IAttribute attribute = null;
				file.write("\n");
				
				for(int j = 0; j < numAttributes; j++)
				{
					attribute = metadata.getAttribute(j);
					file.write(attribute.show(instances.get(i).getValue(j)) + ", ");
				}
				
				for(int j = 0; j < metadata.numberOfClasses(); j++)
				{
					attribute = metadata.getClassAttribute(j);
					
					if(predicted[i][j] == Classes[j])
						file.write("\tHIT");
					else				
						file.write("\tFAIL");
				}
        	}

			file.close();
			
		}catch (IOException e) 
		{
			e.printStackTrace();
		}
    }
    
    /**
     * Compute multi-label classification metrics
     * 
     * @param classifier The classifier
     * @param dataset The dataset
     * 
     * @return array of metrics
     */
    protected double[] computeMetrics(IMLClassifier classifier, IDataset dataset)
	{
		int numClasses = dataset.getMetadata().numberOfClasses();
		int macroPrecisionCount = 0, macroRecallCount = 0, macroAUCCount = 0, macroFMeasureCount = 0;
		int accuracyCount = 0, precisionCount = 0, recallCount = 0;
		int subSetAccuracy = 0;
		
    	double accuracy = 0.0, precision = 0.0, recall = 0.0, hammingLoss = 0.0;
    	double macroPrecision = 0.0, macroRecall = 0.0;
    	double microPrecision = 0.0, microRecall = 0.0;
    	double microFMeasure = 0.0, macroFMeasure = 0.0;
    	double macroAUC = 0.0, microAUC = 0.0;
    	
    	ArrayList<IExample> instances = dataset.getExamples();
    	
    	double[][] predictions = classifier.classify(dataset);
    	
    	int globalTp = 0, globalFp = 0, globalFn = 0, globalTn = 0;
    	
    	int[] classTP = new int[numClasses];
    	int[] classFP = new int[numClasses];
    	int[] classTN = new int[numClasses];
    	int[] classFN = new int[numClasses];
    	
		for(int i = 0; i < instances.size(); i++)
    	{
			Set<Integer> predictedClasses = new HashSet<Integer>();
			Set<Integer> actualClasses = new HashSet<Integer>();
			
			int tp = 0, tn = 0, fp = 0, fn = 0;
			
			for(int j = 0; j < numClasses; j++)
			{
    			if(predictions[i][j] == 1.0)
    				predictedClasses.add(j);
			
    			if(((MLInstance) instances.get(i)).getClassValues()[j] == 1.0)
    				actualClasses.add(j);
    			
    			if(predictions[i][j] == 1.0 && predictions[i][j] == ((MLInstance) instances.get(i)).getClassValues()[j])
    			{
    				tp++;
    				classTP[j]++;
    			}
    			
    			if(predictions[i][j] == 1.0 && predictions[i][j] != ((MLInstance) instances.get(i)).getClassValues()[j])
    			{
    				fp++;
    				classFP[j]++;
    			}

    			if(predictions[i][j] == 0.0 && predictions[i][j] != ((MLInstance) instances.get(i)).getClassValues()[j])
    			{
    				fn++;
    				classFN[j]++;
    			}
    			
    			if(predictions[i][j] == 0.0 && predictions[i][j] == ((MLInstance) instances.get(i)).getClassValues()[j])
    			{
    				tn++;
    				classTN[j]++;
    			}
			}
			
			globalTp += tp;
			globalFp += fp;
			globalFn += fn;
			globalTn += tn;
    		
    		Set<Integer> union = new HashSet<Integer>(actualClasses);
    		union.addAll(predictedClasses);
 		
    		Set<Integer> intersection = new HashSet<Integer>(actualClasses);
    		intersection.retainAll(predictedClasses);
    		
    		if(union.size() != 0)
    		{
    			accuracy += intersection.size() / (double) union.size();
    			accuracyCount++;
    		}
    		
    		double precisionInstance = 0.0, recallInstance = 0.0;
    		
    		if(predictedClasses.size() != 0)
    		{
    			precisionInstance = intersection.size() / (double) predictedClasses.size();
    			precision += precisionInstance;
    			precisionCount++;
    		}
    		
    		if(actualClasses.size() != 0)
    		{
    			recallInstance = intersection.size() / (double) actualClasses.size();
    			recall += recallInstance;
    			recallCount++;
    		}
    		
    		HashSet<Integer> symmetricDifferenceSet = new HashSet<Integer>(union);
    		
    		symmetricDifferenceSet.removeAll(intersection);
    		
    		hammingLoss += symmetricDifferenceSet.size() / (double) numClasses;
    		
    		if(symmetricDifferenceSet.size() == 0)
    			subSetAccuracy++;
    	}
		
		for(int j = 0; j < numClasses; j++)
		{
			if(classTP[j] + classFP[j] != 0)
			{
				macroPrecision += classTP[j] / (double) (classTP[j] + classFP[j]);
				macroPrecisionCount++;
			}
			
			if(classTP[j] + classFN[j] != 0)
			{
				macroRecall += classTP[j] / (double) (classTP[j] + classFN[j]);
				macroRecallCount++;
			}
			
			if(classTP[j] + classFN[j] != 0 && classFP[j] + classTN[j] != 0)
			{
				double tprate, fprate;
				
				tprate = classTP[j] / (double) (classTP[j] + classFN[j]);
				
				fprate = classFP[j] / (double) (classFP[j] + classTN[j]);
				
				macroAUC += (1.0 + tprate - fprate) / 2.0;
				macroAUCCount++;
			}
			
			if(classTP[j] + classFP[j] != 0 && classTP[j] + classFN[j] != 0)
    		{
    			macroFMeasure += (2 * (classTP[j] / (double) (classTP[j] + classFP[j])) * (classTP[j] / (double) (classTP[j] + classFN[j]))) / (double) ((classTP[j] / (double) (classTP[j] + classFP[j])) + (classTP[j] / (double) (classTP[j] + classFN[j])));
    			macroFMeasureCount++;
    		}
		}
		
    	microPrecision = globalTp / (double) (globalTp + globalFp);
    	microRecall = globalTp / (double) (globalTp + globalFn);
    	microAUC = (1.0 + (globalTp / (double) (globalTp + globalFn)) - (globalFp / (double) (globalFp + globalTn))) / 2.0;
    	microFMeasure = (2.0 * microPrecision * microRecall) / (double) (microRecall + microPrecision);

    	double result[] = new double[13 + numClasses];
    	
    	result[0] = accuracy / (double) accuracyCount;
    	result[1] = precision / (double) precisionCount;
    	result[2] = recall / (double) recallCount;
    	result[3] = macroFMeasure / (double) macroFMeasureCount;
    	result[4] = hammingLoss / (double) instances.size();
    	result[5] = macroPrecision / (double) macroPrecisionCount;
    	result[6] = macroRecall / (double) macroRecallCount;
    	result[7] = microPrecision;
    	result[8] = microRecall;
    	result[9] = macroAUC / (double) macroAUCCount;
    	result[10] = microAUC;
    	result[11] = subSetAccuracy / (double) instances.size();
    	result[12] = microFMeasure;
    	
    	for(int j = 0; j < numClasses; j++)
    	{
    		result[j + 13] = (classTP[j] + classTN[j]) / (double) instances.size();
    	}
    	
    	return result;
	}
}
